<!doctype html>
<head><meta charset="utf-8">
<title>Top-Level Await</title><script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"introduction","aoid":null,"title":"Introduction","titleHTML":"Introduction","number":"","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Introduction"},{"type":"op","aoid":"AsyncFunctionStart","refId":"sec-async-functions-abstract-operations-async-function-start","location":"","referencingIds":[],"key":"AsyncFunctionStart"},{"type":"clause","id":"sec-async-functions-abstract-operations-async-function-start","aoid":"AsyncFunctionStart","title":"AsyncFunctionStart ( promiseCapability, asyncFunctionBody )","titleHTML":"AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )","number":"1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"AsyncFunctionStart ( promiseCapability, asyncFunctionBody )"},{"type":"op","aoid":"AsyncBlockStart","refId":"sec-asyncblockstart","location":"","referencingIds":[],"key":"AsyncBlockStart"},{"type":"clause","id":"sec-asyncblockstart","aoid":"AsyncBlockStart","title":"AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )","titleHTML":"<ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins>","number":"2","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_0","_ref_27"],"key":"AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )"},{"type":"op","aoid":"InnerModuleEvaluation","refId":"sec-innermoduleevaluation","location":"","referencingIds":[],"key":"InnerModuleEvaluation"},{"type":"clause","id":"sec-innermoduleevaluation","aoid":"InnerModuleEvaluation","title":"InnerModuleEvaluation( module, stack, index )","titleHTML":"InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )","number":"3.1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_7","_ref_9","_ref_18","_ref_19","_ref_25"],"key":"InnerModuleEvaluation( module, stack, index )"},{"type":"op","aoid":"ModuleExecution","refId":"sec-moduleexecution","location":"","referencingIds":[],"key":"ModuleExecution"},{"type":"clause","id":"sec-moduleexecution","aoid":"ModuleExecution","title":"ModuleExecution( module )","titleHTML":"ModuleExecution( <var>module</var> )","number":"3.2","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_21","_ref_22"],"key":"ModuleExecution( module )"},{"type":"clause","id":"sec-moduleevaluation","aoid":null,"title":"Evaluate( ) Concrete Method","titleHTML":"Evaluate( ) Concrete Method","number":"3","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Evaluate( ) Concrete Method"},{"type":"production","id":"prod-Module","name":"Module","referencingIds":["_ref_44","_ref_45"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Module"},{"type":"production","id":"prod-ModuleBody","name":"ModuleBody","referencingIds":["_ref_29"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"ModuleBody"},{"type":"production","id":"prod-ModuleItemList","name":"ModuleItemList","referencingIds":["_ref_30","_ref_32"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"ModuleItemList"},{"type":"production","id":"prod-ModuleItem","name":"ModuleItem","referencingIds":["_ref_31","_ref_33"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"ModuleItem"},{"type":"clause","id":"sec-modules","aoid":null,"title":"Modules","titleHTML":"Modules","number":"4","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Modules"},{"type":"production","id":"prod-AsyncFunctionDeclaration","name":"AsyncFunctionDeclaration","referencingIds":["_ref_41","_ref_47"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncFunctionDeclaration"},{"type":"production","id":"prod-AsyncFunctionExpression","name":"AsyncFunctionExpression","referencingIds":["_ref_42","_ref_48"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncFunctionExpression"},{"type":"production","id":"prod-AsyncMethod","name":"AsyncMethod","referencingIds":[],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncMethod"},{"type":"production","id":"prod-AsyncFunctionBody","name":"AsyncFunctionBody","referencingIds":["_ref_34","_ref_35","_ref_36","_ref_37","_ref_38","_ref_40","_ref_46"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncFunctionBody"},{"type":"production","id":"prod-AwaitExpression","name":"AwaitExpression","referencingIds":["_ref_39","_ref_43"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AwaitExpression"},{"type":"clause","id":"sec-async-function-definitions","aoid":null,"title":"Async Function Definitions","titleHTML":"Async Function Definitions","number":"5.1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Async Function Definitions"},{"type":"clause","id":"sec-async-function-definitions","aoid":null,"title":"Async Function Definitions","titleHTML":"Async Function Definitions","number":"5","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Async Function Definitions"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#introduction" title="Introduction">Introduction</a></li><li><span class="item-toggle-none"></span><a href="#sec-async-functions-abstract-operations-async-function-start" title="AsyncFunctionStart ( promiseCapability, asyncFunctionBody )"><span class="secnum">1</span> AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-asyncblockstart" title="AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )"><span class="secnum">2</span> <ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins></a></li><li><span class="item-toggle">◢</span><a href="#sec-moduleevaluation" title="Evaluate( ) Concrete Method"><span class="secnum">3</span> Evaluate( ) Concrete Method</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-innermoduleevaluation" title="InnerModuleEvaluation( module, stack, index )"><span class="secnum">3.1</span> InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-moduleexecution" title="ModuleExecution( module )"><span class="secnum">3.2</span> ModuleExecution( <var>module</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-modules" title="Modules"><span class="secnum">4</span> Modules</a></li><li><span class="item-toggle">◢</span><a href="#sec-async-function-definitions" title="Async Function Definitions"><span class="secnum">5</span> Async Function Definitions</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-async-function-definitions" title="Async Function Definitions"><span class="secnum">5.1</span> Async Function Definitions</a></li></ol></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 2 Draft / November 14, 2018</h1><h1 class="title">Top-Level Await</h1>
<script src="ecmarkup.js" defer=""></script>
<link rel="stylesheet" href="ecmarkup.css">

<emu-intro id="introduction">
  <h1>Introduction</h1>

    <p>Top-Level Await allows the <code>await</code> keyword to be used at the top level of the module goal.</p>
</emu-intro>

<emu-clause id="sec-async-functions-abstract-operations-async-function-start" aoid="AsyncFunctionStart">
  <h1><span class="secnum">1</span>AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</h1>
  <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Let <var>asyncContext</var> be a copy of <var>runningContext</var>.</li><li><ins>Perform !&nbsp;<emu-xref aoid="AsyncBlockStart" id="_ref_0"><a href="#sec-asyncblockstart">AsyncBlockStart</a></emu-xref>(<var>promiseCapability</var>, <var>asyncFunctionBody</var>, <var>asyncContext</var>).</ins></li><li><del>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> the following steps will be performed:</del><ol><li><del>Let <var>result</var> be the result of evaluating <var>asyncFunctionBody</var>.</del></li><li><del>Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</del></li><li><del>Remove <var>asyncContext</var> from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and restore the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> that is at the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then</del><ol><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_1"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</del></li></ol></li><li><del>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then</del><ol><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_2"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</del></li></ol></li><li><del>Else,</del><ol><li><del>Assert: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</del></li><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_3"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</del></li></ol></li><li><del>Return.</del></li></ol></li><li><del>Push <var>asyncContext</var> onto the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</del></li><li><del>Assert: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Assert: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 3.g above.</del></li><li>Return.
  </li></ol></emu-alg>
</emu-clause>

<emu-clause id="sec-asyncblockstart" aoid="AsyncBlockStart">
  <h1><span class="secnum">2</span><ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins></h1>
  <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncBody</var>.</li><li>Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and restore the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> that is at the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_4"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_5"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</li></ol></li><li>Else,<ol><li>Assert: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_6"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</li></ol></li><li>Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li>Assert: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Assert: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 2.g above.
  </li></ol></emu-alg>
</emu-clause>

<emu-clause id="sec-moduleevaluation">
  <h1><span class="secnum">3</span>Evaluate( ) Concrete Method</h1>

  <p>The Evaluate concrete method of a <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref> implements the corresponding <emu-xref href="#sec-abstract-module-records"><a href="https://tc39.github.io/ecma262/#sec-abstract-module-records">Module Record</a></emu-xref> abstract method.</p>
  <p><ins>By the time the promise returned by Evaluate settles,  </ins>Evaluate transitions this module's [[Status]] from <code>"instantiated"</code> to <code>"evaluated"</code>.</p>

  <p><del>If execution results in an exception, that exception is recorded in the [[EvaluationError]] field and rethrown by future invocations of Evaluate.</del></p>

  <p><ins>If execution results in a rejected promise, the promise's rejection reason is recorded in the [[EvaluationError]] field. Future invocations of Evaluate will then return a new promise rejected with that same rejection reason.</ins></p>

  <p>This abstract method performs the following steps (most of the work is done by the auxiliary function <emu-xref aoid="InnerModuleEvaluation" id="_ref_7"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>):</p>

  <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref>.</li><li>Assert: <var>module</var>.[[Status]] is <code>"instantiated"</code> or <code>"evaluated"</code>.</li><li><ins>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_8"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</ins></li><li>Let <var>stack</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Let <var>result</var> be <ins>Await(</ins><emu-xref aoid="InnerModuleEvaluation" id="_ref_9"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>(<var>module</var>, <var>stack</var>, 0)<ins>)</ins>.</li><li>If <var>result</var> is an <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">abrupt completion</a></emu-xref>, then<ol><li>For each module <var>m</var> in <var>stack</var>, do<ol><li>Assert: <var>m</var>.[[Status]] is <code>"evaluating"</code>.</li><li>Set <var>m</var>.[[Status]] to <code>"evaluated"</code>.</li><li>Set <var>m</var>.[[EvaluationError]] to <var>result</var>.</li></ol></li><li>Assert: <var>module</var>.[[Status]] is <code>"evaluated"</code> and <var>module</var>.[[EvaluationError]] is <var>result</var>.</li><li><del>Return <var>result</var>.</del></li><li><ins>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_10"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</ins></li><li><ins>Return <var>promiseCapability</var>.[[Promise]].</ins></li></ol></li><li>Assert: <var>module</var>.[[Status]] is <code>"evaluated"</code> and <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>.</li><li>Assert: <var>stack</var> is empty.</li><li><del>Return <emu-val>undefined</emu-val>.</del></li><li><ins>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_11"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</ins></li><li><ins>Return <var>promiseCapability</var>.[[Promise]].</ins>
  </li></ol></emu-alg>

  <emu-clause id="sec-innermoduleevaluation" aoid="InnerModuleEvaluation">
    <h1><span class="secnum">3.1</span>InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>

    <p>The InnerModuleEvaluation abstract operation is used by Evaluate to perform the actual evaluation process for the <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref> <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as <var>module</var>'s [[DFSIndex]] and [[DFSAncestoreIndex]] fields, are used the same way as in InnerModuleInstantiation.</p>

    <p>This abstract operation performs the following steps:</p>

    <emu-alg><ol><li><ins>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_12"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</ins></li><li>If <var>module</var> is not a <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref>, then<ol><li><del>Perform <var>module</var>.Evaluate()</del>.</li><li><del>Return <var>index</var>.</del></li><li><ins>Let <var>evaluateResult</var> be Await(! <var>module</var>.Evaluate())</ins></li><li><ins>If <var>evaluateResult</var> is an <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">abrupt completion</a></emu-xref>, perform !&nbsp;<emu-xref aoid="Call" id="_ref_13"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>evaluateResult</var>.[[Value]]»).</ins></li><li><ins>Otherwise, perform !&nbsp;<emu-xref aoid="Call" id="_ref_14"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>index</var>»).</ins></li><li><ins>Return <var>promiseCapability</var>.[[Promise]].</ins></li></ol></li><li>If <var>module</var>.[[Status]] is <code>"evaluated"</code>, then<ol><li><del>If <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>, return <var>index</var>.</del></li><li><del>Otherwise return <var>module</var>.[[EvaluationError]].</del></li><li><ins>If <var>module</var>.[[EvaluationError]] is an <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">abrupt completion</a></emu-xref>, perform !&nbsp;<emu-xref aoid="Call" id="_ref_15"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>module</var>.[[EvaluationError]].[[Value]]»).</ins></li><li><ins>Otherwise, perform !&nbsp;<emu-xref aoid="Call" id="_ref_16"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>index</var>»).</ins></li><li><ins>Return <var>promiseCapability</var>.[[Promise]]</ins></li></ol></li><li>If <var>module</var>.[[Status]] is <code>"evaluating"</code>, return <var>index</var>.</li><li>Assert: <var>module</var>.[[Status]] is <code>"instantiated"</code>.</li><li>Set <var>module</var>.[[Status]] to <code>"evaluating"</code>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Set <var>index</var> to <var>index</var> + 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be !&nbsp;<emu-xref aoid="HostResolveImportedModule" id="_ref_17"><a href="https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>NOTE: Instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.</li><li><del>Set <var>index</var> to ?&nbsp;<emu-xref aoid="InnerModuleEvaluation" id="_ref_18"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</del></li><li><ins>Let <var>childResult</var> be Await(! <emu-xref aoid="InnerModuleEvaluation" id="_ref_19"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</ins></li><li><ins><emu-xref aoid="IfAbruptRejectPromise" id="_ref_20"><a href="https://tc39.github.io/ecma262/#sec-ifabruptrejectpromise">IfAbruptRejectPromise</a></emu-xref>(<var>childResult</var>, <var>promiseCapability</var>).</ins></li><li>Assert: <var>requiredModule</var>.[[Status]] is either <code>"evaluating"</code> or <code>"evaluated"</code>.</li><li>Assert: <var>requiredModule</var>.[[Status]] is <code>"evaluating"</code> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li>If <var>requiredModule</var>.[[Status]] is <code>"evaluating"</code>, then<ol><li>Assert: <var>requiredModule</var> is a <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li></ol></li><li><del>Perform ?&nbsp;<emu-xref aoid="ModuleExecution" id="_ref_21"><a href="#sec-moduleexecution">ModuleExecution</a></emu-xref>(<var>module</var>).</del></li><li><ins>Let <var>executionResult</var> be Await(! <emu-xref aoid="ModuleExecution" id="_ref_22"><a href="#sec-moduleexecution">ModuleExecution</a></emu-xref>(<var>module</var>)).</ins></li><li><ins><emu-xref aoid="IfAbruptRejectPromise" id="_ref_23"><a href="https://tc39.github.io/ecma262/#sec-ifabruptrejectpromise">IfAbruptRejectPromise</a></emu-xref>(<var>executionResult</var>, <var>promiseCapability</var>).</ins></li><li>Assert: <var>module</var> occurs exactly once in <var>stack</var>.</li><li>Assert: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li>Set <var>requiredModule</var>.[[Status]] to <code>"evaluated"</code>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href="#sec-abstract-module-records"><a href="https://tc39.github.io/ecma262/#sec-abstract-module-records">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li><del>Return <var>index</var>.</del></li><li><ins>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_24"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>index</var>»).</ins></li><li><ins>Return <var>promiseCapability</var>.[[Promise]]</ins>
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-moduleexecution" aoid="ModuleExecution">
    <h1><span class="secnum">3.2</span>ModuleExecution( <var>module</var> )</h1>

    <p>The ModuleExecution abstract operation is used by <emu-xref aoid="InnerModuleEvaluation" id="_ref_25"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref> to initialize the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> of the module and evaluate the module's code within it.</p>

    <p>This abstract operation performs the following steps:</p>

    <emu-alg><ol><li>Let <var>moduleCxt</var> be a new ECMAScript code <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref>.</li><li>Set the Function of <var>moduleCxt</var> to <emu-val>null</emu-val>.</li><li>Assert: <var>module</var>.[[Realm]] is not <emu-val>undefined</emu-val>.</li><li>Set the <emu-xref href="#realm"><a href="https://tc39.github.io/ecma262/#realm">Realm</a></emu-xref> of <var>moduleCxt</var> to <var>module</var>.[[Realm]].</li><li>Set the ScriptOrModule of <var>moduleCxt</var> to <var>module</var>.</li><li>Assert: <var>module</var> has been linked and declarations in its <emu-xref href="#module-environment"><a href="https://tc39.github.io/ecma262/#module-environment">module environment</a></emu-xref> have been instantiated.</li><li>Set the VariableEnvironment of <var>moduleCxt</var> to <var>module</var>.[[Environment]].</li><li>Set the LexicalEnvironment of <var>moduleCxt</var> to <var>module</var>.[[Environment]].</li><li><ins>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_26"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</ins></li><li>Suspend the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li><ins>Perform !&nbsp;<emu-xref aoid="AsyncBlockStart" id="_ref_27"><a href="#sec-asyncblockstart">AsyncBlockStart</a></emu-xref>(<var>promiseCapability</var>, <var>module</var>.[[ECMAScriptCode]], <var>moduleCxt</var>).</ins></li><li><del>Push <var>moduleCxt</var> on to the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>moduleCxt</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Let <var>result</var> be the result of evaluating <var>module</var>.[[ECMAScriptCode]].</del></li><li><del>Suspend <var>moduleCxt</var> and remove it from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>.</del></li><li>Resume the context that is now on the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li><del>Return <emu-xref aoid="Completion" id="_ref_28"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">Completion</a></emu-xref>(<var>result</var>).</del></li><li><ins>Return <var>promiseCapability</var>.[[Promise]].</ins>
    </li></ol></emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-modules">
    <h1><span class="secnum">4</span>Modules</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition"><emu-production name="Module" id="prod-Module">
    <emu-nt><a href="#prod-Module">Module</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="52f49b96"><emu-nt optional="" id="_ref_29"><a href="#prod-ModuleBody">ModuleBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="ModuleBody" id="prod-ModuleBody">
    <emu-nt><a href="#prod-ModuleBody">ModuleBody</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="89010d7d"><emu-nt id="_ref_30"><a href="#prod-ModuleItemList">ModuleItemList</a></emu-nt></emu-rhs>
</emu-production>
<emu-production name="ModuleItemList" id="prod-ModuleItemList">
    <emu-nt><a href="#prod-ModuleItemList">ModuleItemList</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="029ec31e"><emu-nt id="_ref_31"><a href="#prod-ModuleItem">ModuleItem</a></emu-nt></emu-rhs>
    <emu-rhs a="75ddb725"><emu-nt id="_ref_32"><a href="#prod-ModuleItemList">ModuleItemList</a></emu-nt><emu-nt id="_ref_33"><a href="#prod-ModuleItem">ModuleItem</a></emu-nt></emu-rhs>
</emu-production>
<emu-production name="ModuleItem" id="prod-ModuleItem">
    <emu-nt><a href="#prod-ModuleItem">ModuleItem</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="e0559377"><emu-nt><a href="https://tc39.github.io/ecma262/#prod-ImportDeclaration">ImportDeclaration</a></emu-nt></emu-rhs>
    <emu-rhs a="298e81b0"><emu-nt><a href="https://tc39.github.io/ecma262/#prod-ExportDeclaration">ExportDeclaration</a></emu-nt></emu-rhs><del>
    <emu-rhs a="b8d22333"><emu-nt params="~Yield, ~Await, ~Return"><a href="https://tc39.github.io/ecma262/#prod-StatementListItem">StatementListItem</a><emu-mods><emu-params>[~Yield, ~Await, ~Return]</emu-params></emu-mods></emu-nt></emu-rhs></del>
    <ins><emu-rhs a="41359050"><emu-nt params="~Yield, +Await, ~Return"><a href="https://tc39.github.io/ecma262/#prod-StatementListItem">StatementListItem</a><emu-mods><emu-params>[~Yield, +Await, ~Return]</emu-params></emu-mods></emu-nt></emu-rhs>
</ins></emu-production></emu-grammar>
</emu-clause>

<emu-clause id="sec-async-function-definitions">
  <h1><span class="secnum">5</span>Async Function Definitions</h1>
  <h2>Syntax</h2>
  <emu-clause id="sec-async-function-definitions">
    <h1><span class="secnum">5.1</span>Async Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition"><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" id="prod-AsyncFunctionDeclaration">
    <emu-nt params="Yield, Await, Default"><a href="#prod-AsyncFunctionDeclaration">AsyncFunctionDeclaration</a><emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="f512250e"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await"><a href="https://tc39.github.io/ecma262/#prod-BindingIdentifier">BindingIdentifier</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_34"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="af38773a" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_35"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncFunctionExpression" id="prod-AsyncFunctionExpression">
    <emu-nt><a href="#prod-AsyncFunctionExpression">AsyncFunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="c25b1d19"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_36"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="be6457e0"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-BindingIdentifier">BindingIdentifier</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_37"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncMethod" params="Yield, Await" id="prod-AsyncMethod">
    <emu-nt params="Yield, Await"><a href="#prod-AsyncMethod">AsyncMethod</a><emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="a922691e"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-nt params="?Yield, ?Await"><a href="https://tc39.github.io/ecma262/#prod-PropertyName">PropertyName</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-UniqueFormalParameters">UniqueFormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_38"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncFunctionBody" id="prod-AsyncFunctionBody">
    <emu-nt><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="8ff4dc7c"><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FunctionBody">FunctionBody</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="AwaitExpression" params="Yield" id="prod-AwaitExpression">
    <emu-nt params="Yield"><a href="#prod-AwaitExpression">AwaitExpression</a><emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="c19c56e7"><emu-t>await</emu-t><emu-nt params="?Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-UnaryExpression">UnaryExpression</a><emu-mods><emu-params>[?Yield, +Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></emu-grammar>

    <emu-note><span class="note">Note</span><div class="note-contents">
      <p><code>await</code> is parsed as an <emu-nt id="_ref_39"><a href="#prod-AwaitExpression">AwaitExpression</a></emu-nt> when the  <sub>[Await]</sub> parameter is present. The  <sub>[Await]</sub> parameter is present in the following contexts:</p>
      <ul>
        <li>In an <emu-nt id="_ref_40"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt>.</li>
        <li>In the <emu-nt><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a></emu-nt> of an <emu-nt id="_ref_41"><a href="#prod-AsyncFunctionDeclaration">AsyncFunctionDeclaration</a></emu-nt>, <emu-nt id="_ref_42"><a href="#prod-AsyncFunctionExpression">AsyncFunctionExpression</a></emu-nt>, <emu-nt>AsyncGeneratorDeclaration</emu-nt>, or <emu-nt>AsyncGeneratorExpression</emu-nt>. <emu-nt id="_ref_43"><a href="#prod-AwaitExpression">AwaitExpression</a></emu-nt> in this position is a Syntax error via static semantics.</li>
        <li><ins>When <emu-nt id="_ref_44"><a href="#prod-Module">Module</a></emu-nt> is the syntactic <emu-xref href="#sec-context-free-grammars"><a href="https://tc39.github.io/ecma262/#sec-context-free-grammars">goal symbol</a></emu-xref></ins></li>
      </ul>
      <p><del>When <emu-nt id="_ref_45"><a href="#prod-Module">Module</a></emu-nt> is the syntactic <emu-xref href="#sec-context-free-grammars"><a href="https://tc39.github.io/ecma262/#sec-context-free-grammars">goal symbol</a></emu-xref> and the  <sub>[Await]</sub> parameter is absent, <code>await</code> is parsed as a keyword and will be a Syntax error.</del> When <emu-nt><a href="https://tc39.github.io/ecma262/#prod-Script">Script</a></emu-nt> is the syntactic <emu-xref href="#sec-context-free-grammars"><a href="https://tc39.github.io/ecma262/#sec-context-free-grammars">goal symbol</a></emu-xref>, <code>await</code> may be parsed as an identifier when the  <sub>[Await]</sub> parameter is absent. This includes the following contexts:</p>
      <ul>
        <li>Anywhere outside of an <emu-nt id="_ref_46"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt> or <emu-nt><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a></emu-nt> of an <emu-nt id="_ref_47"><a href="#prod-AsyncFunctionDeclaration">AsyncFunctionDeclaration</a></emu-nt>, <emu-nt id="_ref_48"><a href="#prod-AsyncFunctionExpression">AsyncFunctionExpression</a></emu-nt>, <emu-nt>AsyncGeneratorDeclaration</emu-nt>, or <emu-nt>AsyncGeneratorExpression</emu-nt>.</li>
        <li>In the <emu-nt><a href="https://tc39.github.io/ecma262/#prod-BindingIdentifier">BindingIdentifier</a></emu-nt> of a <emu-nt><a href="https://tc39.github.io/ecma262/#prod-FunctionExpression">FunctionExpression</a></emu-nt>, <emu-nt><a href="https://tc39.github.io/ecma262/#prod-GeneratorExpression">GeneratorExpression</a></emu-nt>, or <emu-nt>AsyncGeneratorExpression</emu-nt>.</li>
      </ul>
    </div></emu-note>
</emu-clause>
</emu-clause></div></body>