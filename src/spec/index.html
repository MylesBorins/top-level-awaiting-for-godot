<!doctype html>
<head><meta charset="utf-8">
<title>Top-Level Await</title><script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"introduction","aoid":null,"title":"Introduction","titleHTML":"Introduction","number":"","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Introduction"},{"type":"op","aoid":"AsyncFunctionStart","refId":"sec-async-functions-abstract-operations-async-function-start","location":"","referencingIds":[],"key":"AsyncFunctionStart"},{"type":"clause","id":"sec-async-functions-abstract-operations-async-function-start","aoid":"AsyncFunctionStart","title":"AsyncFunctionStart ( promiseCapability, asyncFunctionBody )","titleHTML":"AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )","number":"1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"AsyncFunctionStart ( promiseCapability, asyncFunctionBody )"},{"type":"op","aoid":"AsyncBlockStart","refId":"sec-asyncblockstart","location":"","referencingIds":[],"key":"AsyncBlockStart"},{"type":"clause","id":"sec-asyncblockstart","aoid":"AsyncBlockStart","title":"AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )","titleHTML":"<ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins>","number":"2","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_2","_ref_54"],"key":"AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )"},{"type":"table","id":"table-36","number":1,"caption":"Table 1: Module Record Fields","referencingIds":[],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Table 1: Module Record Fields"},{"type":"table","id":"table-37","number":2,"caption":"Table 2: Abstract Methods of Module Records","referencingIds":["_ref_0"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Table 2: Abstract Methods of Module Records"},{"type":"term","term":"ResolvedBinding Record","refId":"sec-abstract-module-records","referencingIds":[],"id":"resolvedbinding-record","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"ResolvedBinding Record"},{"type":"clause","id":"sec-abstract-module-records","aoid":null,"title":"Abstract Module Records","titleHTML":"Abstract Module Records","number":"3","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_9","_ref_10","_ref_11","_ref_13","_ref_14","_ref_16","_ref_18","_ref_19","_ref_22","_ref_23","_ref_24","_ref_25","_ref_29","_ref_34","_ref_38","_ref_52","_ref_57"],"key":"Abstract Module Records"},{"type":"table","id":"table-cyclic-module-fields","number":3,"caption":"Table 3: Additional Fields of Cyclic Module Records","referencingIds":[],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Table 3: Additional Fields of Cyclic Module Records"},{"type":"table","id":"table-cyclic-module-methods","number":4,"caption":"Table 4: Additional Abstract Methods of Cyclic Module Records","referencingIds":["_ref_1"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Table 4: Additional Abstract Methods of Cyclic Module Records"},{"type":"op","aoid":"InnerModuleInstantiation","refId":"sec-innermoduleinstantiation","location":"","referencingIds":[],"key":"InnerModuleInstantiation"},{"type":"clause","id":"sec-innermoduleinstantiation","aoid":"InnerModuleInstantiation","title":"InnerModuleInstantiation ( module, stack, index )","titleHTML":"InnerModuleInstantiation ( <var>module</var>, <var>stack</var>, <var>index</var> )","number":"4.1.1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_15","_ref_17","_ref_21","_ref_30","_ref_55","_ref_61","_ref_62","_ref_63","_ref_64","_ref_65","_ref_66"],"key":"InnerModuleInstantiation ( module, stack, index )"},{"type":"clause","id":"sec-moduledeclarationinstantiation","aoid":null,"title":"Instantiate ( ) Concrete Method","titleHTML":"Instantiate ( ) Concrete Method","number":"4.1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Instantiate ( ) Concrete Method"},{"type":"op","aoid":"InnerModuleEvaluation","refId":"sec-innermoduleevaluation","location":"","referencingIds":[],"key":"InnerModuleEvaluation"},{"type":"clause","id":"sec-innermoduleevaluation","aoid":"InnerModuleEvaluation","title":"InnerModuleEvaluation( module, stack, index )","titleHTML":"InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )","number":"4.2.1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_26","_ref_28","_ref_33","_ref_56","_ref_67","_ref_68"],"key":"InnerModuleEvaluation( module, stack, index )"},{"type":"op","aoid":"ExecuteModuleWhenImportsReady","refId":"sec-execute-module-when-imports-ready","location":"","referencingIds":[],"key":"ExecuteModuleWhenImportsReady"},{"type":"clause","id":"sec-execute-module-when-imports-ready","aoid":"ExecuteModuleWhenImportsReady","title":"ExecuteModuleWhenImportsReady( module, promises, capability )","titleHTML":"<ins>ExecuteModuleWhenImportsReady( <var>module</var>, <var>promises</var>, <var>capability</var> )</ins>","number":"4.2.2","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_37","_ref_69"],"key":"ExecuteModuleWhenImportsReady( module, promises, capability )"},{"type":"clause","id":"sec-moduleevaluation","aoid":null,"title":"Evaluate ( ) Concrete Method","titleHTML":"Evaluate ( ) Concrete Method","number":"4.2","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Evaluate ( ) Concrete Method"},{"type":"op","aoid":"ParseModule","refId":"sec-parsemodule","location":"","referencingIds":[],"key":"ParseModule"},{"type":"clause","id":"sec-parsemodule","aoid":"ParseModule","title":"ParseModule ( sourceText, realm, hostDefined )","titleHTML":"ParseModule ( <var>sourceText</var>, <var>realm</var>, <var>hostDefined</var> )","number":"4.3.1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_59","_ref_70"],"key":"ParseModule ( sourceText, realm, hostDefined )"},{"type":"op","aoid":"ExecuteModule","refId":"sec-source-text-module-record-execute-module","location":"","referencingIds":[],"key":"ExecuteModule"},{"type":"clause","id":"sec-source-text-module-record-execute-module","aoid":"ExecuteModule","title":"ExecuteModule ( [  capability ] )","titleHTML":"ExecuteModule ( [  <ins><var>capability</var></ins> ] )","number":"4.3.2","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_12","_ref_35","_ref_39","_ref_40","_ref_41"],"key":"ExecuteModule ( [  capability ] )"},{"type":"clause","id":"sec-source-text-module-records","aoid":null,"title":"Source Text Module Records","titleHTML":"Source Text Module Records","number":"4.3","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_27","_ref_31","_ref_48","_ref_50","_ref_51"],"key":"Source Text Module Records"},{"type":"figure","id":"figure-module-graph-simple","number":1,"caption":"Figure 1: A simple module graph","referencingIds":[],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Figure 1: A simple module graph"},{"type":"figure","id":"figure-module-graph-missing","number":2,"caption":"Figure 2: A module graph with an unresolvable module","referencingIds":[],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Figure 2: A module graph with an unresolvable module"},{"type":"figure","id":"figure-module-graph-cycle","number":3,"caption":"Figure 3: A cyclic module graph","referencingIds":[],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Figure 3: A cyclic module graph"},{"type":"clause","id":"sec-example-source-text-module-record-graphs","aoid":null,"title":"Example Source Text Module Record Graphs","titleHTML":"Example Source Text Module Record Graphs","number":"4.4","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Example Source Text Module Record Graphs"},{"type":"op","aoid":"TopLevelModuleEvaluationJob","refId":"sec-toplevelmoduleevaluationjob","location":"","referencingIds":[],"key":"TopLevelModuleEvaluationJob"},{"type":"clause","id":"sec-toplevelmoduleevaluationjob","aoid":"TopLevelModuleEvaluationJob","title":"Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText, hostDefined )","titleHTML":"Runtime Semantics: TopLevelModuleEvaluationJob ( <var>sourceText</var>, <var>hostDefined</var> )","number":"4.5","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText, hostDefined )"},{"type":"clause","id":"sec-cyclic-module-records","aoid":null,"title":"Cyclic Module Records","titleHTML":"Cyclic Module Records","number":"4","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Cyclic Module Records"},{"type":"production","id":"prod-Module","name":"Module","referencingIds":["_ref_76","_ref_77","_ref_79","_ref_80","_ref_96","_ref_97"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"Module"},{"type":"production","id":"prod-ModuleBody","name":"ModuleBody","referencingIds":["_ref_81"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"ModuleBody"},{"type":"production","id":"prod-ModuleItemList","name":"ModuleItemList","referencingIds":["_ref_82","_ref_84"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"ModuleItemList"},{"type":"production","id":"prod-ModuleItem","name":"ModuleItem","referencingIds":["_ref_83","_ref_85"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"ModuleItem"},{"type":"clause","id":"sec-modules","aoid":null,"title":"Modules","titleHTML":"Modules","number":"5","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Modules"},{"type":"production","id":"prod-AsyncFunctionDeclaration","name":"AsyncFunctionDeclaration","referencingIds":["_ref_93","_ref_99"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncFunctionDeclaration"},{"type":"production","id":"prod-AsyncFunctionExpression","name":"AsyncFunctionExpression","referencingIds":["_ref_94","_ref_100"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncFunctionExpression"},{"type":"production","id":"prod-AsyncMethod","name":"AsyncMethod","referencingIds":[],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncMethod"},{"type":"production","id":"prod-AsyncFunctionBody","name":"AsyncFunctionBody","referencingIds":["_ref_86","_ref_87","_ref_88","_ref_89","_ref_90","_ref_92","_ref_98"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AsyncFunctionBody"},{"type":"production","id":"prod-AwaitExpression","name":"AwaitExpression","referencingIds":["_ref_78","_ref_91","_ref_95"],"namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","key":"AwaitExpression"},{"type":"clause","id":"sec-async-function-definitions","aoid":null,"title":"Async Function Definitions","titleHTML":"Async Function Definitions","number":"6.1","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Async Function Definitions"},{"type":"clause","id":"sec-async-function-definitions","aoid":null,"title":"Async Function Definitions","titleHTML":"Async Function Definitions","number":"6","namespace":"https://tc39.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Async Function Definitions"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#introduction" title="Introduction">Introduction</a></li><li><span class="item-toggle-none"></span><a href="#sec-async-functions-abstract-operations-async-function-start" title="AsyncFunctionStart ( promiseCapability, asyncFunctionBody )"><span class="secnum">1</span> AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-asyncblockstart" title="AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )"><span class="secnum">2</span> <ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins></a></li><li><span class="item-toggle-none"></span><a href="#sec-abstract-module-records" title="Abstract Module Records"><span class="secnum">3</span> Abstract Module Records</a></li><li><span class="item-toggle">◢</span><a href="#sec-cyclic-module-records" title="Cyclic Module Records"><span class="secnum">4</span> Cyclic Module Records</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-moduledeclarationinstantiation" title="Instantiate ( ) Concrete Method"><span class="secnum">4.1</span> Instantiate ( ) Concrete Method</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-innermoduleinstantiation" title="InnerModuleInstantiation ( module, stack, index )"><span class="secnum">4.1.1</span> InnerModuleInstantiation ( <var>module</var>, <var>stack</var>, <var>index</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-moduleevaluation" title="Evaluate ( ) Concrete Method"><span class="secnum">4.2</span> Evaluate ( ) Concrete Method</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-innermoduleevaluation" title="InnerModuleEvaluation( module, stack, index )"><span class="secnum">4.2.1</span> InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-execute-module-when-imports-ready" title="ExecuteModuleWhenImportsReady( module, promises, capability )"><span class="secnum">4.2.2</span> <ins>ExecuteModuleWhenImportsReady( <var>module</var>, <var>promises</var>, <var>capability</var> )</ins></a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-source-text-module-records" title="Source Text Module Records"><span class="secnum">4.3</span> Source Text Module Records</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-parsemodule" title="ParseModule ( sourceText, realm, hostDefined )"><span class="secnum">4.3.1</span> ParseModule ( <var>sourceText</var>, <var>realm</var>, <var>hostDefined</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-source-text-module-record-execute-module" title="ExecuteModule ( [  capability ] )"><span class="secnum">4.3.2</span> ExecuteModule ( [  <ins><var>capability</var></ins> ] )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-example-source-text-module-record-graphs" title="Example Source Text Module Record Graphs"><span class="secnum">4.4</span> Example Source Text Module Record Graphs</a></li><li><span class="item-toggle-none"></span><a href="#sec-toplevelmoduleevaluationjob" title="Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText, hostDefined )"><span class="secnum">4.5</span> RS: TopLevelModuleEvaluationJob ( <var>sourceText</var>, <var>hostDefined</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-modules" title="Modules"><span class="secnum">5</span> Modules</a></li><li><span class="item-toggle">◢</span><a href="#sec-async-function-definitions" title="Async Function Definitions"><span class="secnum">6</span> Async Function Definitions</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-async-function-definitions" title="Async Function Definitions"><span class="secnum">6.1</span> Async Function Definitions</a></li></ol></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 2 Draft / May 6, 2019</h1><h1 class="title">Top-Level Await</h1>
<script src="ecmarkup.js" defer=""></script>
<link rel="stylesheet" href="ecmarkup.css">

<emu-intro id="introduction">
  <h1>Introduction</h1>

    <p>Top-Level Await allows the <code>await</code> keyword to be used at the top level of the module goal. See  <a href="https://github.com/tc39/proposal-top-level-await/blob/master/README.md">the explainer</a> for the motivation, context, and high-level semantics.</p>
</emu-intro>

<emu-clause id="sec-async-functions-abstract-operations-async-function-start" aoid="AsyncFunctionStart">
  <h1><span class="secnum">1</span>AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</h1>
  <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Let <var>asyncContext</var> be a copy of <var>runningContext</var>.</li><li><ins>Perform !&nbsp;<emu-xref aoid="AsyncBlockStart" id="_ref_2"><a href="#sec-asyncblockstart">AsyncBlockStart</a></emu-xref>(<var>promiseCapability</var>, <var>asyncFunctionBody</var>, <var>asyncContext</var>).</ins></li><li><del>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> the following steps will be performed:</del><ol><li><del>Let <var>result</var> be the result of evaluating <var>asyncFunctionBody</var>.</del></li><li><del>Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</del></li><li><del>Remove <var>asyncContext</var> from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and restore the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> that is at the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then</del><ol><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_3"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</del></li></ol></li><li><del>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then</del><ol><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_4"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</del></li></ol></li><li><del>Else,</del><ol><li><del>Assert: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</del></li><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_5"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</del></li></ol></li><li><del>Return.</del></li></ol></li><li><del>Push <var>asyncContext</var> onto the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</del></li><li><del>Assert: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Assert: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 3.g above.</del></li><li>Return.
  </li></ol></emu-alg>
</emu-clause>

<emu-clause id="sec-asyncblockstart" aoid="AsyncBlockStart">
  <h1><span class="secnum">2</span><ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins></h1>
  <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncBody</var>.</li><li>Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and restore the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> that is at the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_6"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_7"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</li></ol></li><li>Else,<ol><li>Assert: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_8"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</li></ol></li><li>Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li>Assert: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Assert: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 2.g above.
  </li></ol></emu-alg>
</emu-clause>

<emu-clause id="sec-abstract-module-records">
  <h1><span class="secnum">3</span>Abstract Module Records</h1>
  <emu-table id="table-36" caption="Module Record Fields"><figure><figcaption>Table 1: <emu-xref href="#sec-abstract-module-records" id="_ref_9"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> Fields</figcaption>
    <table>
      <thead>
      <tr>
        <th>
          Field Name
        
        </th>
        <th>
          Value Type
        
        </th>
        <th>
          Meaning
        
        </th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>
          [[Realm]]
        
        </td>
        <td>
          <emu-xref href="#realm-record"><a href="https://tc39.github.io/ecma262/#realm-record">Realm Record</a></emu-xref> | <emu-val>undefined</emu-val>
        
        </td>
        <td>
          The <emu-xref href="#realm"><a href="https://tc39.github.io/ecma262/#realm">Realm</a></emu-xref> within which this module was created. <emu-val>undefined</emu-val> if not yet assigned.
        
        </td>
      </tr>
      <tr>
        <td>
          [[Environment]]
        
        </td>
        <td>
          <emu-xref href="#sec-lexical-environments"><a href="https://tc39.github.io/ecma262/#sec-lexical-environments">Lexical Environment</a></emu-xref> | <emu-val>undefined</emu-val>
        
        </td>
        <td>
          The <emu-xref href="#sec-lexical-environments"><a href="https://tc39.github.io/ecma262/#sec-lexical-environments">Lexical Environment</a></emu-xref> containing the top level bindings for this module. This field is set when the module is instantiated.
        
        </td>
      </tr>
      <tr>
        <td>
          [[Namespace]]
        
        </td>
        <td>
          Object | <emu-val>undefined</emu-val>
        
        </td>
        <td>
          The Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"><a href="https://tc39.github.io/ecma262/#sec-module-namespace-objects">26.3</a></emu-xref>) if one has been created for this module. Otherwise <emu-val>undefined</emu-val>.
        
        </td>
      </tr>
      <tr>
        <td>
          [[HostDefined]]
        
        </td>
        <td>
          Any, default value is <emu-val>undefined</emu-val>.
        
        </td>
        <td>
          Field reserved for use by host environments that need to associate additional information with a module.
        
        </td>
      </tr>
      <tr>
        <td>
          <ins>[[Async]]</ins>
        </td>
        <td>
          <ins><emu-val>true</emu-val> or <emu-val>false</emu-val></ins>
        </td>
        <td>
          <ins>Indicates whether this module is asynchronous. Abstract <emu-xref href="#sec-abstract-module-records" id="_ref_10"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> subclasses must not modify this field after the Instantiation phase.</ins>
        </td>
      </tr>
      <tr>
        <td>
          <ins>[[EvaluationPromise]]</ins>
        </td>
        <td>
          <ins><emu-val>undefined</emu-val> | Promise</ins>
        </td>
        <td>
          <ins>If [[Async]] is true, and evaluation of this module has begun, this field stores a Promise that resolves or rejects when evaluation of the module is complete.</ins>
        </td>
      </tr>
      </tbody>
    </table>
  </figure></emu-table>

  <emu-note type="editor"><span class="note">Editor's Note</span><div class="note-contents">
    <p>For all module types defined in this specification, it's statically determined (given the set of parsed modules and the graph connecting them) whether a module will have an [[EvaluationPromise]] which is not <emu-val>undefined</emu-val> after Evaluate() is called. A Promise is only present if the module or a dependency has the [[Async]] flag set. As more module types are added, the intention is that this would remain the case. However, concepts like "dependency" are not defined on Abstract Module Records.</p>
  </div></emu-note>

  <emu-table id="table-37" caption="Abstract Methods of Module Records"><figure><figcaption>Table 2: Abstract Methods of Module Records</figcaption>
    <table>
      <tbody>
      <tr>
        <th>
          Method
        
        </th>
        <th>
          Purpose
        
        </th>
      </tr>
      <tr>
        <td>
          GetExportedNames(<var>exportStarSet</var>)
        
        </td>
        <td>
          Return a list of all names that are either directly or indirectly exported from this module.
        
        </td>
      </tr>
      <tr>
        <td>
          ResolveExport(<var>exportName</var>, <var>resolveSet</var>)
        
        </td>
        <td>
          <p>Return the binding of a name exported by this module. Bindings are represented by a  <dfn id="resolvedbinding-record">ResolvedBinding Record</dfn>, of the form { [[Module]]: <emu-xref href="#sec-abstract-module-records" id="_ref_11"><a href="#sec-abstract-module-records">Module Record</a></emu-xref>, [[BindingName]]: String }. Return <emu-val>null</emu-val> if the name cannot be resolved, or <code>"ambiguous"</code> if multiple bindings were found.</p>
          <p>This operation must be idempotent if it completes normally. Each time it is called with a specific <var>exportName</var>, <var>resolveSet</var> pair as arguments it must return the same result.</p>
        </td>
      </tr>
      <tr>
        <td>
          Instantiate()
        
        </td>
        <td>
          <p>Prepare the module for evaluation by transitively resolving all module dependencies and creating a module <emu-xref href="#sec-environment-records"><a href="https://tc39.github.io/ecma262/#sec-environment-records">Environment Record</a></emu-xref>.</p>
        </td>
      </tr>
      <tr>
        <td>
          Evaluate()
        
        </td>
        <td>
          <p>If this module has already been evaluated successfully, return <emu-val>undefined</emu-val>; if it has already been evaluated unsuccessfully, throw the exception that was produced. Otherwise, Transitively evaluate all module dependencies of this module and then evaluate this module.</p>
          <p>Instantiate must have completed successfully prior to invoking this method.</p>
        </td>
      </tr>
      </tbody>
    </table>
  </figure></emu-table>
</emu-clause>

<emu-clause id="sec-cyclic-module-records">
  <h1><span class="secnum">4</span>Cyclic Module Records</h1>

  <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records"><figure><figcaption>Table 3: Additional Fields of Cyclic Module Records</figcaption>
    <table>
      <tbody>
        <tr>
          <th>
            Field Name
          
          </th>
          <th>
            Value Type
          
          </th>
          <th>
            Meaning
          
          </th>
        </tr>
        <tr>
          <td>
            [[Status]]
          
          </td>
          <td>
            String
          
          </td>
          <td>
            Initially <code>"uninstantiated"</code>. Transitions to <code>"instantiating"</code>, <code>"instantiated"</code>, <code>"evaluating"</code>, <code>"evaluated"</code> (in that order) as the module progresses throughout its lifecycle.
          
          </td>
        </tr>
        <tr>
          <td>
            [[EvaluationError]]
          
          </td>
          <td>
            An <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">abrupt completion</a></emu-xref> | <emu-val>undefined</emu-val>
          
          </td>
          <td>
            A completion of type <emu-const>throw</emu-const> representing the exception that occurred during evaluation.  <emu-val>undefined</emu-val> if no exception occurred,  <ins>if the module is [[Async]],</ins> or if [[Status]] is not <code>"evaluated"</code>.
          
          </td>
        </tr>
        <tr>
          <td>
            [[DFSIndex]]
          
          </td>
          <td>
            Integer | <emu-val>undefined</emu-val>
          
          </td>
          <td>
            Auxiliary field used during Instantiate and Evaluate only.
            If [[Status]] is <code>"instantiating"</code> or <code>"evaluating"</code>, this nonnegative number records the point at which the module was first visited during the ongoing depth-first traversal of the dependency graph.
          
          </td>
        </tr>
        <tr>
          <td>
            [[DFSAncestorIndex]]
          
          </td>
          <td>
            Integer | <emu-val>undefined</emu-val>
          
          </td>
          <td>
            Auxiliary field used during Instantiate and Evaluate only. If [[Status]] is <code>"instantiating"</code> or <code>"evaluating"</code>, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
          
          </td>
        </tr>
        <tr>
          <td>
            [[RequestedModules]]
          
          </td>
          <td>
            <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of String
          
          </td>
          <td>
            A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of all the <emu-nt><a href="https://tc39.github.io/ecma262/#prod-ModuleSpecifier">ModuleSpecifier</a></emu-nt> strings used by the module represented by this record to request the importation of a module. The <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> is source code occurrence ordered.
          
          </td>
        </tr>
        <tr>
          <td>
            <ins>[[ModuleAsync]]</ins>
          </td>
          <td>
            <ins><emu-val>true</emu-val> or <emu-val>false</emu-val></ins>
          </td>
          <td>
            <ins>Whether this module is individually asynchronous. A module may have [[Async]] <emu-val>true</emu-val> and [[ModuleAsync]] <emu-val>false</emu-val> if dependencies are asynchronous, but this module is not. This field must not change after the module is parsed.</ins>
          </td>
        </tr>
      </tbody>
    </table>
  </figure></emu-table>
  <p>In addition to the methods defined in  <emu-xref href="#table-37" id="_ref_0"><a href="#table-37">Table 2</a></emu-xref> Cyclic Module Records have the additional methods listed in  <emu-xref href="#table-cyclic-module-methods" id="_ref_1"><a href="#table-cyclic-module-methods">Table 4</a></emu-xref></p>
  <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records"><figure><figcaption>Table 4: Additional Abstract Methods of Cyclic Module Records</figcaption>
    <table>
      <tbody>
        <tr>
          <th>
            Method
          
          </th>
          <th>
            Purpose
          
          </th>
        </tr>
        <tr>
          <td>
            InitializeEnvironment()
          
          </td>
          <td>
            Initialize the <emu-xref href="#sec-lexical-environments"><a href="https://tc39.github.io/ecma262/#sec-lexical-environments">Lexical Environment</a></emu-xref> of the module, including resolving all imported bindings.
          
          </td>
        </tr>
        <tr>
          <td>
            <emu-xref aoid="ExecuteModule" id="_ref_12"><a href="#sec-source-text-module-record-execute-module">ExecuteModule</a></emu-xref>(  <ins>[ <var>promiseCapability</var> ]</ins> )
          
          </td>
          <td>
            Initialize the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> of the module and evaluate the module's code within it.  <ins>If this module has <emu-val>true</emu-val> in [[ModuleAsync]], then a Promise Capability is passed as an argument, and the method is expected to resolve or reject the given capability. In this case, the method must not throw an exception, but instead reject the Promise Capability if necessary.</ins>
          </td>
        </tr>
        </tbody>
      </table>
    </figure></emu-table>

  <emu-clause id="sec-moduledeclarationinstantiation">
    <h1><span class="secnum">4.1</span>Instantiate ( ) Concrete Method</h1>

    <p>The Instantiate concrete method of a Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_13"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> implements the corresponding <emu-xref href="#sec-abstract-module-records" id="_ref_14"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> abstract method.</p>
    <p>On success, Instantiate transitions this module's [[Status]] from <code>"uninstantiated"</code> to <code>"instantiated"</code>. On failure, an exception is thrown and this module's [[Status]] remains <code>"uninstantiated"</code>.</p>

    <p>This abstract method performs the following steps (most of the work is done by the auxiliary function <emu-xref aoid="InnerModuleInstantiation" id="_ref_15"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref>):</p>

    <emu-alg><ol><li>Let <var>module</var> be this Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_16"><a href="#sec-abstract-module-records">Module Record</a></emu-xref>.</li><li>Assert: <var>module</var>.[[Status]] is not <code>"instantiating"</code> or <code>"evaluating"</code>.</li><li>Let <var>stack</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Let <var>result</var> be <emu-xref aoid="InnerModuleInstantiation" id="_ref_17"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref>(<var>module</var>, <var>stack</var>, 0).</li><li>If <var>result</var> is an <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">abrupt completion</a></emu-xref>, then<ol><li>For each module <var>m</var> in <var>stack</var>, do<ol><li>Assert: <var>m</var>.[[Status]] is <code>"instantiating"</code>.</li><li>Set <var>m</var>.[[Status]] to <code>"uninstantiated"</code>.</li><li>Set <var>m</var>.[[Environment]] to <emu-val>undefined</emu-val>.</li><li>Set <var>m</var>.[[DFSIndex]] to <emu-val>undefined</emu-val>.</li><li>Set <var>m</var>.[[DFSAncestorIndex]] to <emu-val>undefined</emu-val>.</li></ol></li><li>Assert: <var>module</var>.[[Status]] is <code>"uninstantiated"</code>.</li><li>Return <var>result</var>.</li></ol></li><li>Assert: <var>module</var>.[[Status]] is <code>"instantiated"</code> or <code>"evaluated"</code>.</li><li>Assert: <var>stack</var> is empty.</li><li>Return <emu-val>undefined</emu-val>.
    </li></ol></emu-alg>

    <emu-clause id="sec-innermoduleinstantiation" aoid="InnerModuleInstantiation">
      <h1><span class="secnum">4.1.1</span>InnerModuleInstantiation ( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>

      <p>The InnerModuleInstantiation abstract operation is used by Instantiate to perform the actual instantiation process for the Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_18"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to <code>"instantiated"</code> together.</p>

      <p>This abstract operation performs the following steps:</p>

      <emu-alg><ol><li>If <var>module</var> is not a Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_19"><a href="#sec-abstract-module-records">Module Record</a></emu-xref>, then<ol><li>Perform ? <var>module</var>.Instantiate().</li><li>Return <var>index</var>.</li></ol></li><li>If <var>module</var>.[[Status]] is <code>"instantiating"</code>, <code>"instantiated"</code>, or <code>"evaluated"</code>, then<ol><li>Return <var>index</var>.</li></ol></li><li>Assert: <var>module</var>.[[Status]] is <code>"uninstantiated"</code>.</li><li>Set <var>module</var>.[[Status]] to <code>"instantiating"</code>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Increase <var>index</var> by 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be ?&nbsp;<emu-xref aoid="HostResolveImportedModule" id="_ref_20"><a href="https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>Set <var>index</var> to ?&nbsp;<emu-xref aoid="InnerModuleInstantiation" id="_ref_21"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</li><li>Assert: <var>requiredModule</var>.[[Status]] is either <code>"instantiating"</code>, <code>"instantiated"</code>, or <code>"evaluated"</code>.</li><li>Assert: <var>requiredModule</var>.[[Status]] is <code>"instantiating"</code> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li>If <var>requiredModule</var>.[[Status]] is <code>"instantiating"</code>, then<ol><li>Assert: <var>requiredModule</var> is a Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_22"><a href="#sec-abstract-module-records">Module Record</a></emu-xref>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li><li><ins>If <var>requiredModule</var>.[[Async]] is <emu-val>true</emu-val>, then</ins><ol><li><ins>Set <var>module</var>.[[Async]] to <emu-val>true</emu-val>.</ins></li></ol></li></ol></li><li>Perform ? <var>module</var>.InitializeEnvironment().</li><li>Assert: <var>module</var> occurs exactly once in <var>stack</var>.</li><li>Assert: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li>Set <var>requiredModule</var>.[[Status]] to <code>"instantiated"</code>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href="#sec-abstract-module-records" id="_ref_23"><a href="#sec-abstract-module-records">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Return <var>index</var>.
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-moduleevaluation">
    <h1><span class="secnum">4.2</span>Evaluate ( ) Concrete Method</h1>

    <p>The Evaluate concrete method of a Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_24"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> implements the corresponding <emu-xref href="#sec-abstract-module-records" id="_ref_25"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> abstract method.</p>
    <p>Evaluate transitions this module's [[Status]] from <code>"instantiated"</code> to <code>"evaluated"</code>.</p>

    <p>If execution results in a  <ins>synchronous</ins> exception, that exception is recorded in the [[EvaluationError]] field and rethrown by future invocations of Evaluate.</p>

    <p>This abstract method performs the following steps (most of the work is done by the auxiliary function <emu-xref aoid="InnerModuleEvaluation" id="_ref_26"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>):</p>

    <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href="#sec-source-text-module-records" id="_ref_27"><a href="#sec-source-text-module-records">Source Text Module Record</a></emu-xref>.</li><li>Assert: <var>module</var>.[[Status]] is <code>"instantiated"</code> or <code>"evaluated"</code>.</li><li>Let <var>stack</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Let <var>result</var> be <emu-xref aoid="InnerModuleEvaluation" id="_ref_28"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>(<var>module</var>, <var>stack</var>, 0).</li><li>If <var>result</var> is an <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">abrupt completion</a></emu-xref>, then<ol><li>For each module <var>m</var> in <var>stack</var>, do<ol><li>Assert: <var>m</var>.[[Status]] is <code>"evaluating"</code>.</li><li><ins>If <var>m</var>.[[Async]] is <emu-val>true</emu-val>, return <var>result</var>.</ins></li><li>Set <var>m</var>.[[Status]] to <code>"evaluated"</code>.</li><li>Set <var>m</var>.[[EvaluationError]] to <var>result</var>.</li></ol></li><li>Assert: <var>module</var>.[[Status]] is <code>"evaluated"</code> and <var>module</var>.[[EvaluationError]] is <var>result</var>.</li><li>Return <var>result</var>.</li></ol></li><li>Assert: <var>module</var>.[[Status]] is <code>"evaluated"</code> and <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>.</li><li>Assert: <var>stack</var> is empty.</li><li><ins>If <var>module</var>.[[Async]] is <emu-val>true</emu-val>, return <var>module</var>.[[EvaluationPromise]].</ins></li><li><ins>Otherwise</ins>, return <emu-val>undefined</emu-val>.
    </li></ol></emu-alg>

    <emu-clause id="sec-innermoduleevaluation" aoid="InnerModuleEvaluation">
      <h1><span class="secnum">4.2.1</span>InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>

      <p>The InnerModuleEvaluation abstract operation is used by Evaluate to perform the actual evaluation process for the Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_29"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as <var>module</var>'s [[DFSIndex]] and [[DFSAncestoreIndex]] fields, are used the same way as in <emu-xref aoid="InnerModuleInstantiation" id="_ref_30"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref>.</p>

      <p>This abstract operation performs the following steps:</p>

      <emu-alg><ol><li>If <var>module</var> is not a <emu-xref href="#sec-source-text-module-records" id="_ref_31"><a href="#sec-source-text-module-records">Source Text Module Record</a></emu-xref>, then<ol><li>Perform <var>module</var>.Evaluate().</li><li>Return <var>index</var>.</li></ol></li><li>If <var>module</var>.[[Status]] is <code>"evaluated"</code>, then<ol><li>If <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>, return <var>index</var>.</li><li>Otherwise return <var>module</var>.[[EvaluationError]].</li></ol></li><li>If <var>module</var>.[[Status]] is <code>"evaluating"</code>, return <var>index</var>.</li><li>Assert: <var>module</var>.[[Status]] is <code>"instantiated"</code>.</li><li>Set <var>module</var>.[[Status]] to <code>"evaluating"</code>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Set <var>index</var> to <var>index</var> + 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li><ins>Let <var>asyncDependencies</var> be an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</ins></li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be !&nbsp;<emu-xref aoid="HostResolveImportedModule" id="_ref_32"><a href="https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>NOTE: Instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.</li><li>Set <var>index</var> to ?&nbsp;<emu-xref aoid="InnerModuleEvaluation" id="_ref_33"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</li><li>Assert: <var>requiredModule</var>.[[Status]] is either <code>"evaluating"</code> or <code>"evaluated"</code>.</li><li>Assert: <var>requiredModule</var>.[[Status]] is <code>"evaluating"</code> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li><ins>If <var>requiredModule</var>.[[Status]] is <code>"evaluated"</code>, and <var>requiredModule</var>.[[Async]] is <emu-val>true</emu-val>, then</ins><ol><li><ins>Assert: <var>module</var>.[[Async]] is <emu-val>true</emu-val>.</ins></li><li><ins>Append <var>requiredModule</var>.[[EvaluationPromise]] to <var>asyncDependencies</var>.</ins></li></ol></li><li>If <var>requiredModule</var>.[[Status]] is <code>"evaluating"</code>, then<ol><li>Assert: <var>requiredModule</var> is a Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_34"><a href="#sec-abstract-module-records">Module Record</a></emu-xref>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li></ol></li><li><ins>If <var>module</var>.[[Async]] is <emu-val>false</emu-val>, then</ins><ol><li>Perform ? <var>module</var>.<emu-xref aoid="ExecuteModule" id="_ref_35"><a href="#sec-source-text-module-record-execute-module">ExecuteModule</a></emu-xref>()</li></ol></li><li><ins>Otherwise,</ins><ol><li><ins>Let <var>capability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_36"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</ins></li><li><ins>Set <var>module</var>.[[EvaluationPromise]] to <var>capability</var>.[[Promise]].</ins></li><li><ins>Perform !&nbsp;<emu-xref aoid="ExecuteModuleWhenImportsReady" id="_ref_37"><a href="#sec-execute-module-when-imports-ready">ExecuteModuleWhenImportsReady</a></emu-xref>(<var>module</var>, <var>asyncDependencies</var>, <var>capability</var>).</ins></li></ol></li><li>Assert: <var>module</var> occurs exactly once in <var>stack</var>.</li><li>Assert: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li>Set <var>requiredModule</var>.[[Status]] to <code>"evaluated"</code>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href="#sec-abstract-module-records" id="_ref_38"><a href="#sec-abstract-module-records">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li><li><ins>Otherwise, if <var>module</var>.[[Async]] is <emu-val>true</emu-val>,</ins><ol><li><ins>Set <var>requiredModule</var>.[[EvaluationPromise]] to <var>module</var>.[[EvaluationPromise]].</ins></li></ol></li></ol></li></ol></li><li>Return <var>index</var>.
      </li></ol></emu-alg>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>A module is <code>"evaluating"</code> while it is being traversed by InnerModuleEvaluation. A module is <code>"evaluated"</code> when ModuleExecution has been called, even if that module execution is a promise that has not yet resolved.</p>
      </div></emu-note>
    </emu-clause>

  <emu-clause id="sec-execute-module-when-imports-ready" aoid="ExecuteModuleWhenImportsReady">
    <h1><span class="secnum">4.2.2</span><ins>ExecuteModuleWhenImportsReady( <var>module</var>, <var>promises</var>, <var>capability</var> )</ins></h1>
    <emu-alg><ol><li>If <var>promises</var> is an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>,<ol><li>Assert: <var>module</var>.[[ModuleAsync]] is <emu-val>true</emu-val>.</li><li>Perform ! <var>module</var>.<emu-xref aoid="ExecuteModule" id="_ref_39"><a href="#sec-source-text-module-record-execute-module">ExecuteModule</a></emu-xref>(<var>capability</var>).</li><li>Return.</li></ol></li><li>Let <var>index</var> be 0.</li><li>Let <var>fullfilledCount</var> be 0.</li><li>Let <var>total</var> be the length of the <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> <var>promises</var>.</li><li>For each Promise <var>promise</var> in <var>promises</var>, do<ol><li>Let <var>stepsFulfilled</var> be the following steps with argument <var>arg</var><ol><li>Assert: <var>arg</var> is <emu-val>undefined</emu-val>.</li><li>Set <var>fulfilledCount</var> to <var>fulfilledCount</var> + 1.</li><li>If <var>fulfilledCount</var> is equal to <var>total</var>, then<ol><li>If <var>module</var>.[[ModuleAsync]] is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>module</var>.<emu-xref aoid="ExecuteModule" id="_ref_40"><a href="#sec-source-text-module-record-execute-module">ExecuteModule</a></emu-xref>(<var>capability</var>).</li></ol></li><li>Otherwise,<ol><li>Let <var>result</var> be <var>module</var>.<emu-xref aoid="ExecuteModule" id="_ref_41"><a href="#sec-source-text-module-record-execute-module">ExecuteModule</a></emu-xref>().</li><li>If <var>result</var> is a normal completion, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_42"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</li></ol></li><li>Otherwise,<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_43"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</li></ol></li></ol></li></ol></li></ol></li><li>Let <var>onFulfilled</var> be <emu-xref aoid="CreateBuiltinFunction" id="_ref_44"><a href="https://tc39.github.io/ecma262/#sec-createbuiltinfunction">CreateBuiltinFunction</a></emu-xref>(<var>stepsFulfilled</var>).</li><li>Let <var>stepsReject</var> be the following steps with argument <var>arg</var><ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_45"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>capability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>arg</var>»).</li></ol></li><li>Let <var>onReject</var> be <emu-xref aoid="CreateBuiltinFunction" id="_ref_46"><a href="https://tc39.github.io/ecma262/#sec-createbuiltinfunction">CreateBuiltinFunction</a></emu-xref>(<var>stepsReject</var>).</li><li>Perform !&nbsp;<emu-xref aoid="PerformPromiseThen" id="_ref_47"><a href="https://tc39.github.io/ecma262/#sec-performpromisethen">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var>).</li></ol></li><li>Return.
    </li></ol></emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-source-text-module-records">
    <h1><span class="secnum">4.3</span>Source Text Module Records</h1>

  <emu-clause id="sec-parsemodule" aoid="ParseModule">
    <h1><span class="secnum">4.3.1</span>ParseModule ( <var>sourceText</var>, <var>realm</var>, <var>hostDefined</var> )</h1>
    <p>The abstract operation ParseModule with arguments <var>sourceText</var>, <var>realm</var>, and <var>hostDefined</var> creates a <emu-xref href="#sec-source-text-module-records" id="_ref_48"><a href="#sec-source-text-module-records">Source Text Module Record</a></emu-xref> based upon the result of parsing <var>sourceText</var> as a <emu-nt id="_ref_76"><a href="#prod-Module">Module</a></emu-nt>. ParseModule performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>sourceText</var> is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-source-code">10</a></emu-xref>).</li><li>Parse <var>sourceText</var> using <emu-nt id="_ref_77"><a href="#prod-Module">Module</a></emu-nt> as the <emu-xref href="#sec-context-free-grammars"><a href="https://tc39.github.io/ecma262/#sec-context-free-grammars">goal symbol</a></emu-xref> and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let <var>body</var> be the resulting parse tree. Otherwise, let <var>body</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of one or more <emu-val>SyntaxError</emu-val> or <emu-val>ReferenceError</emu-val> objects representing the parsing errors and/or early errors. Parsing and <emu-xref href="#early-error"><a href="https://tc39.github.io/ecma262/#early-error">early error</a></emu-xref> detection may be interweaved in an implementation-dependent manner. If more than one parsing error or <emu-xref href="#early-error"><a href="https://tc39.github.io/ecma262/#early-error">early error</a></emu-xref> is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.</li><li>If <var>body</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of errors, return <var>body</var>.</li><li>Let <var>requestedModules</var> be the ModuleRequests of <var>body</var>.</li><li>Let <var>importEntries</var> be ImportEntries of <var>body</var>.</li><li>Let <var>importedBoundNames</var> be <emu-xref aoid="ImportedLocalNames" id="_ref_49"><a href="https://tc39.github.io/ecma262/#sec-importedlocalnames">ImportedLocalNames</a></emu-xref>(<var>importEntries</var>).</li><li>Let <var>indirectExportEntries</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Let <var>localExportEntries</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Let <var>starExportEntries</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Let <var>exportEntries</var> be ExportEntries of <var>body</var>.</li><li>For each ExportEntry <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>ee</var> in <var>exportEntries</var>, do<ol><li>If <var>ee</var>.[[ModuleRequest]] is <emu-val>null</emu-val>, then<ol><li>If <var>ee</var>.[[LocalName]] is not an element of <var>importedBoundNames</var>, then<ol><li>Append <var>ee</var> to <var>localExportEntries</var>.</li></ol></li><li>Else,<ol><li>Let <var>ie</var> be the element of <var>importEntries</var> whose [[LocalName]] is the same as <var>ee</var>.[[LocalName]].</li><li>If <var>ie</var>.[[ImportName]] is <code>"*"</code>, then<ol><li>Assert: This is a re-export of an imported module namespace object.</li><li>Append <var>ee</var> to <var>localExportEntries</var>.</li></ol></li><li>Else this is a re-export of a single name,<ol><li>Append the ExportEntry <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> { [[ModuleRequest]]: <var>ie</var>.[[ModuleRequest]], [[ImportName]]: <var>ie</var>.[[ImportName]], [[LocalName]]: <emu-val>null</emu-val>, [[ExportName]]: <var>ee</var>.[[ExportName]] } to <var>indirectExportEntries</var>.</li></ol></li></ol></li></ol></li><li>Else if <var>ee</var>.[[ImportName]] is <code>"*"</code>, then<ol><li>Append <var>ee</var> to <var>starExportEntries</var>.</li></ol></li><li>Else,<ol><li>Append <var>ee</var> to <var>indirectExportEntries</var>.</li></ol></li></ol></li><li><ins>Let <var>async</var> be <var>body</var> Contains <emu-nt id="_ref_78"><a href="#prod-AwaitExpression">AwaitExpression</a></emu-nt>.</ins></li><li>Return <emu-xref href="#sec-source-text-module-records" id="_ref_50"><a href="#sec-source-text-module-records">Source Text Module Record</a></emu-xref> { [[Realm]]: <var>realm</var>, [[Environment]]: <emu-val>undefined</emu-val>, [[Namespace]]: <emu-val>undefined</emu-val>, <ins>[[EvaluationPromise]]: <emu-val>undefined</emu-val>, </ins>[[Status]]: <code>"uninstantiated"</code>, [[EvaluationError]]: <emu-val>undefined</emu-val>, [[HostDefined]]: <var>hostDefined</var>, [[ECMAScriptCode]]: <var>body</var>, [[RequestedModules]]: <var>requestedModules</var>, [[ImportEntries]]: <var>importEntries</var>, [[LocalExportEntries]]: <var>localExportEntries</var>, [[IndirectExportEntries]]: <var>indirectExportEntries</var>, [[StarExportEntries]]: <var>starExportEntries</var>, [[DFSIndex]]: <emu-val>undefined</emu-val>, [[DFSAncestorIndex]]: <emu-val>undefined</emu-val>, <ins>[[Async]]: <var>async</var>, [[ModuleAsync]]: <var>async</var></ins> }.
    </li></ol></emu-alg>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>An implementation may parse module source text and analyse it for Early Error conditions prior to the evaluation of ParseModule for that module source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseModule upon that source text.</p>
    </div></emu-note>
  </emu-clause>


    <emu-clause id="sec-source-text-module-record-execute-module" aoid="ExecuteModule">
      <h1><span class="secnum">4.3.2</span>ExecuteModule ( [  <ins><var>capability</var></ins> ] )</h1>

      <p>The ExecuteModule concrete method of a <emu-xref href="#sec-source-text-module-records" id="_ref_51"><a href="#sec-source-text-module-records">Source Text Module Record</a></emu-xref> implements the corresponding Cyclic <emu-xref href="#sec-abstract-module-records" id="_ref_52"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> abstract method.</p>

      <emu-alg><ol><li>Let <var>moduleCxt</var> be a new ECMAScript code <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref>.</li><li>Set the Function of <var>moduleCxt</var> to <emu-val>null</emu-val>.</li><li>Assert: <var>module</var>.[[Realm]] is not <emu-val>undefined</emu-val>.</li><li>Set the <emu-xref href="#realm"><a href="https://tc39.github.io/ecma262/#realm">Realm</a></emu-xref> of <var>moduleCxt</var> to <var>module</var>.[[Realm]].</li><li>Set the ScriptOrModule of <var>moduleCxt</var> to <var>module</var>.</li><li>Assert: <var>module</var> has been linked and declarations in its <emu-xref href="#module-environment"><a href="https://tc39.github.io/ecma262/#module-environment">module environment</a></emu-xref> have been instantiated.</li><li>Set the VariableEnvironment of <var>moduleCxt</var> to <var>module</var>.[[Environment]].</li><li>Set the LexicalEnvironment of <var>moduleCxt</var> to <var>module</var>.[[Environment]].</li><li>Suspend the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li><ins>If <var>module</var>.[[ModuleAsync]] is <emu-val>false</emu-val>, then</ins><ol><li><ins>Assert: <var>capability</var> was not provided.</ins></li><li>Push <var>moduleCxt</var> on to the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>moduleCxt</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Let <var>result</var> be the result of evaluating <var>module</var>.[[ECMAScriptCode]].</li><li>Suspend <var>moduleCxt</var> and remove it from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>.</li><li>Resume the context that is now on the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Return <emu-xref aoid="Completion" id="_ref_53"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">Completion</a></emu-xref>(<var>result</var>).</li></ol></li><li><ins>Otherwise,</ins><ol><li><ins>Assert: <var>capability</var> was provided.</ins></li><li><ins>Perform !&nbsp;<emu-xref aoid="AsyncBlockStart" id="_ref_54"><a href="#sec-asyncblockstart">AsyncBlockStart</a></emu-xref>(<var>capability</var>, <var>module</var>.[[ECMAScriptCode]], <var>moduleCxt</var>).</ins></li><li><ins>Return.</ins>
      </li></ol></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-example-source-text-module-record-graphs">
    <h1><span class="secnum">4.4</span>Example Source Text Module Record Graphs</h1>

    <p>This non-normative section gives a series of examples of the instantiation and evaluation of a few common module graphs, with a specific focus on how errors can occur.</p>

    <p>First consider the following simple module graph:</p>

    <emu-figure id="figure-module-graph-simple" caption="A simple module graph"><figure><figcaption>Figure 1: A simple module graph</figcaption>
      <img alt="A module graph in which module A depends on module B" width="121" height="211" src="img/module-graph-simple.svg">
    </figure></emu-figure>

    <p>Let's first assume that there are no error conditions. When a host first calls <var>A</var>.Instantiate(), this will complete successfully by assumption, and recursively instantiate modules <var>B</var> and <var>C</var> as well, such that <var>A</var>.[[Status]] = <var>B</var>.[[Status]] = <var>C</var>.[[Status]] = <code>"instantiated"</code>. This preparatory step can be performed at any time. Later, when the host is ready to incur any possible side effects of the modules, it can call <var>A</var>.Evaluate(), which will complete successfully<ins>, returning a Promsie resolving to <emu-val>undefined</emu-val></ins> (again by assumption), recursively having evaluated first <var>C</var> and then <var>B</var>. Each module's [[Status]] at this point will be <code>"evaluated</code>".</p>

    <p>Consider then cases involving instantiation errors. If <emu-xref aoid="InnerModuleInstantiation" id="_ref_55"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref> of <var>C</var> succeeds but, thereafter, fails for <var>B</var>, for example because it imports something that <var>C</var> does not provide, then the original <var>A</var>.Instantiate() will fail, and both <var>A</var> and <var>B</var>'s [[Status]] remain <code>"uninstantiated"</code>. <var>C</var>'s [[Status]] has become <code>"instantiated"</code>, though.</p>

    <p>Finally, consider a case involving evaluation errors. If <emu-xref aoid="InnerModuleEvaluation" id="_ref_56"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref> of <var>C</var> succeeds but, thereafter, fails for <var>B</var>, for example because <var>B</var> contains code that throws an exception, then the original <var>A</var>.Evaluate() will fail<ins>, returning a Promise resolving to <emu-val>undefined</emu-val></ins>. The resulting exception will be recorded in both <var>A</var> and <var>B</var>'s  <del>[[EvaluationError]]</del><ins>[[EvaluationResult]]</ins> fields, and their [[Status]] will become <code>"evaluated"</code>. <var>C</var> will also become <code>"evaluated"</code> but, in contrast to <var>A</var> and <var>B</var>, will  <del>remain without an [[EvaluationError]]</del><ins>have its [[EvaluationResult]] internal slot set to <emu-val>undefined</emu-val></ins>, as it successfully completed evaluation. Storing the exception  <ins>in [[EvaluationResult]]</ins> ensures that any time a host tries to reuse <var>A</var> or <var>B</var> by calling their Evaluate() method, it will encounter the same exception. (Hosts are not required to reuse Source Text Module Records; similarly, hosts are not required to expose the exception objects thrown by these  methods. However, the specification enables such uses.)</p>

    <p>The difference here between instantiation and evaluation errors is due to how evaluation must be only performed once, as it can cause side effects; it is thus important to remember whether evaluation has already been performed, even if unsuccessfully. (In the error case, it makes sense to also remember the exception because otherwise subsequent Evaluate() calls would have to synthesize a new one.) Instantiation, on the other hand, is side-effect-free, and thus even if it fails, it can be retried at a later time with no issues.</p>

    <p>Now consider a different type of error condition:</p>

    <emu-figure id="figure-module-graph-missing" caption="A module graph with an unresolvable module"><figure><figcaption>Figure 2: A module graph with an unresolvable module</figcaption>
      <img alt="A module graph in which module A depends on a missing (unresolvable) module, represented by ???" width="121" height="121" src="img/module-graph-missing.svg">
    </figure></emu-figure>

    <p>In this scenario, module <var>A</var> declares a dependency on some other module, but no <emu-xref href="#sec-abstract-module-records" id="_ref_57"><a href="#sec-abstract-module-records">Module Record</a></emu-xref> exists for that module, i.e. <emu-xref aoid="HostResolveImportedModule" id="_ref_58"><a href="https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule">HostResolveImportedModule</a></emu-xref> throws an exception when asked for it. This could occur for a variety of reasons, such as the corresponding resource not existing, or the resource existing but <emu-xref aoid="ParseModule" id="_ref_59"><a href="#sec-parsemodule">ParseModule</a></emu-xref> throwing an exception when trying to parse the resulting source text. Hosts can choose to expose the cause of failure via the exception they throw from <emu-xref aoid="HostResolveImportedModule" id="_ref_60"><a href="https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule">HostResolveImportedModule</a></emu-xref>. In any case, this exception causes an instantiation failure, which as before results in <var>A</var>'s [[Status]] remaining <code>"uninstantiated"</code>.</p>

    <p>Lastly, consider a module graph with a cycle:</p>

    <emu-figure id="figure-module-graph-cycle" caption="A cyclic module graph"><figure><figcaption>Figure 3: A cyclic module graph</figcaption>
      <img alt="A module graph in which module A depends on module B and C, but module B also depends on module A" width="181" height="121" src="img/module-graph-cycle.svg">
    </figure></emu-figure>

    <p>Here we assume that the entry point is module <var>A</var>, so that the host proceeds by calling <var>A</var>.Instantiate(), which performs <emu-xref aoid="InnerModuleInstantiation" id="_ref_61"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref> on <var>A</var>. This in turn calls <emu-xref aoid="InnerModuleInstantiation" id="_ref_62"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref> on <var>B</var>. Because of the cycle, this again triggers <emu-xref aoid="InnerModuleInstantiation" id="_ref_63"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref> on <var>A</var>, but at this point it is a no-op since <var>A</var>.[[Status]] is already <code>"instantiating"</code>. <var>B</var>.[[Status]] itself remains <code>"instantiating"</code> when control gets back to <var>A</var> and <emu-xref aoid="InnerModuleInstantiation" id="_ref_64"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref> is triggered on <var>C</var>. After this returns with <var>C</var>.[[Status]] being <code>"instantiated"</code> , both <var>A</var> and <var>B</var> transition from <code>"instantiating"</code> to <code>"instantiated"</code> together; this is by design, since they form a strongly connected component.</p>

    <p>An analogous story occurs for the evaluation phase of a cyclic module graph, in the success case.</p>

    <p>Now consider a case where <var>A</var> has an instantiation error; for example, it tries to import a binding from <var>C</var> that does not exist. In that case, the above steps still occur, including the early return from the second call to <emu-xref aoid="InnerModuleInstantiation" id="_ref_65"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref> on <var>A</var>. However, once we unwind back to the original <emu-xref aoid="InnerModuleInstantiation" id="_ref_66"><a href="#sec-innermoduleinstantiation">InnerModuleInstantiation</a></emu-xref> on <var>A</var>, it fails during ModuleDeclarationEnvironmentSetup, namely right after <var>C</var>.ResolveExport(). The thrown <emu-val>SyntaxError</emu-val> exception propagates up to <var>A</var>.Instantiate, which resets all modules that are currently on its <var>stack</var> (these are always exactly the modules that are still <code>"instantiating"</code>). Hence both <var>A</var> and <var>B</var> become <code>"uninstantiated"</code>. Note that <var>C</var> is left as <code>"instantiated"</code>.</p>

    <p>Finally, consider a case where <var>A</var> has an evaluation error; for example, its source code throws an exception. In that case, the evaluation-time analog of the above steps still occurs, including the early return from the second call to <emu-xref aoid="InnerModuleEvaluation" id="_ref_67"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref> on <var>A</var>. However, once we unwind back to the original <emu-xref aoid="InnerModuleEvaluation" id="_ref_68"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref> on <var>A</var>, it fails by assumption. The exception thrown propagates up to <var>A</var>.Evaluate()  <del>, which records the error in all modules that are currently on its <var>stack</var> (i.e., the modules that are still <code>"evaluating"</code>)</del><ins>via Promise rejections, which form a chain through the whole dependency graph due to <emu-xref aoid="ExecuteModuleWhenImportsReady" id="_ref_69"><a href="#sec-execute-module-when-imports-ready">ExecuteModuleWhenImportsReady</a></emu-xref></ins>. Hence both <var>A</var> and <var>B</var> become <code>"evaluated"</code> and the exception is recorded in both <var>A</var> and <var>B</var>'s  <del>[[EvaluationError]]</del><ins>[[EvaluationResult]]</ins> fields, while <var>C</var> is left as <code>"evaluated"</code> with  <del>no [[EvaluationError]]</del><ins>its [[EvaluationResult]] set to <emu-val>undefined</emu-val>.</ins></p>
  </emu-clause>

  <emu-clause id="sec-toplevelmoduleevaluationjob" aoid="TopLevelModuleEvaluationJob">
    <h1><span class="secnum">4.5</span>Runtime Semantics: TopLevelModuleEvaluationJob ( <var>sourceText</var>, <var>hostDefined</var> )</h1>
    <p>A TopLevelModuleEvaluationJob with parameters <var>sourceText</var> and <var>hostDefined</var> is a job that parses, validates, and evaluates <var>sourceText</var> as a <emu-nt id="_ref_79"><a href="#prod-Module">Module</a></emu-nt>.</p>
    <emu-alg><ol><li>Assert: <var>sourceText</var> is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-source-code">10</a></emu-xref>).</li><li>Let <var>realm</var> be <emu-xref href="#current-realm"><a href="https://tc39.github.io/ecma262/#current-realm">the current Realm Record</a></emu-xref>.</li><li>Let <var>m</var> be <emu-xref aoid="ParseModule" id="_ref_70"><a href="#sec-parsemodule">ParseModule</a></emu-xref>(<var>sourceText</var>, <var>realm</var>, <var>hostDefined</var>).</li><li>If <var>m</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of errors, then<ol><li>Perform <emu-xref aoid="HostReportErrors" id="_ref_71"><a href="https://tc39.github.io/ecma262/#sec-host-report-errors">HostReportErrors</a></emu-xref>(<var>m</var>).</li><li>Return <emu-xref aoid="NormalCompletion" id="_ref_72"><a href="https://tc39.github.io/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></li><li>Perform ? <var>m</var>.Instantiate().</li><li>Assert: All dependencies of <var>m</var> have been transitively resolved and <var>m</var> is ready for evaluation.</li><li><del>Return</del><ins>Let <var>promise</var> be</ins> ? <var>m</var>.Evaluate().</li><li><ins>Let <var>stepsRejected</var> be the following steps with argument <var>reason</var></ins><ol><li><ins>Perform <emu-xref aoid="HostReportErrors" id="_ref_73"><a href="https://tc39.github.io/ecma262/#sec-host-report-errors">HostReportErrors</a></emu-xref>(« <var>reason</var> »).</ins></li></ol></li><li><ins>Let <var>onRejected</var> be <emu-xref aoid="CreateBuiltinFunction" id="_ref_74"><a href="https://tc39.github.io/ecma262/#sec-createbuiltinfunction">CreateBuiltinFunction</a></emu-xref>(<var>stepsRejected</var>).</ins></li><li><ins>Perform !&nbsp;<emu-xref aoid="PerformPromiseThen" id="_ref_75"><a href="https://tc39.github.io/ecma262/#sec-performpromisethen">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <emu-val>undefined</emu-val>, <var>onRejected</var>).</ins></li><li><ins>Return.</ins>
    </li></ol></emu-alg>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>An implementation may parse a <var>sourceText</var> as a <emu-nt id="_ref_80"><a href="#prod-Module">Module</a></emu-nt>, analyse it for Early Error conditions, and instantiate it prior to the execution of the TopLevelModuleEvaluationJob for that <var>sourceText</var>. An implementation may also resolve, pre-parse and pre-analyse, and pre-instantiate module dependencies of <var>sourceText</var>. However, the reporting of any errors detected by these actions must be deferred until the TopLevelModuleEvaluationJob is actually executed.</p>
    </div></emu-note>
  </emu-clause>

</emu-clause>

<emu-clause id="sec-modules">
    <h1><span class="secnum">5</span>Modules</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition"><emu-production name="Module" id="prod-Module">
    <emu-nt><a href="#prod-Module">Module</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="52f49b96"><emu-nt optional="" id="_ref_81"><a href="#prod-ModuleBody">ModuleBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="ModuleBody" id="prod-ModuleBody">
    <emu-nt><a href="#prod-ModuleBody">ModuleBody</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="89010d7d"><emu-nt id="_ref_82"><a href="#prod-ModuleItemList">ModuleItemList</a></emu-nt></emu-rhs>
</emu-production>
<emu-production name="ModuleItemList" id="prod-ModuleItemList">
    <emu-nt><a href="#prod-ModuleItemList">ModuleItemList</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="029ec31e"><emu-nt id="_ref_83"><a href="#prod-ModuleItem">ModuleItem</a></emu-nt></emu-rhs>
    <emu-rhs a="75ddb725"><emu-nt id="_ref_84"><a href="#prod-ModuleItemList">ModuleItemList</a></emu-nt><emu-nt id="_ref_85"><a href="#prod-ModuleItem">ModuleItem</a></emu-nt></emu-rhs>
</emu-production>
<emu-production name="ModuleItem" id="prod-ModuleItem">
    <emu-nt><a href="#prod-ModuleItem">ModuleItem</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="e0559377"><emu-nt><a href="https://tc39.github.io/ecma262/#prod-ImportDeclaration">ImportDeclaration</a></emu-nt></emu-rhs>
    <emu-rhs a="298e81b0"><emu-nt><a href="https://tc39.github.io/ecma262/#prod-ExportDeclaration">ExportDeclaration</a></emu-nt></emu-rhs>
    <del><emu-rhs a="b8d22333"><emu-nt params="~Yield, ~Await, ~Return"><a href="https://tc39.github.io/ecma262/#prod-StatementListItem">StatementListItem</a><emu-mods><emu-params>[~Yield, ~Await, ~Return]</emu-params></emu-mods></emu-nt></emu-rhs></del>
    <ins><emu-rhs a="41359050"><emu-nt params="~Yield, +Await, ~Return"><a href="https://tc39.github.io/ecma262/#prod-StatementListItem">StatementListItem</a><emu-mods><emu-params>[~Yield, +Await, ~Return]</emu-params></emu-mods></emu-nt></emu-rhs></ins>
</emu-production></emu-grammar>
</emu-clause>

<emu-clause id="sec-async-function-definitions">
  <h1><span class="secnum">6</span>Async Function Definitions</h1>
  <h2>Syntax</h2>
  <emu-clause id="sec-async-function-definitions">
    <h1><span class="secnum">6.1</span>Async Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition"><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" id="prod-AsyncFunctionDeclaration">
    <emu-nt params="Yield, Await, Default"><a href="#prod-AsyncFunctionDeclaration">AsyncFunctionDeclaration</a><emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="f512250e"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await"><a href="https://tc39.github.io/ecma262/#prod-BindingIdentifier">BindingIdentifier</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_86"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="fef042b8" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_87"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncFunctionExpression" id="prod-AsyncFunctionExpression">
    <emu-nt><a href="#prod-AsyncFunctionExpression">AsyncFunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="c25b1d19"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_88"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="be6457e0"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-BindingIdentifier">BindingIdentifier</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_89"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncMethod" params="Yield, Await" id="prod-AsyncMethod">
    <emu-nt params="Yield, Await"><a href="#prod-AsyncMethod">AsyncMethod</a><emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="a922691e"><emu-t>async</emu-t><emu-gann>[no <emu-nt><a href="https://tc39.github.io/ecma262/#prod-LineTerminator">LineTerminator</a></emu-nt> here]</emu-gann><emu-nt params="?Yield, ?Await"><a href="https://tc39.github.io/ecma262/#prod-PropertyName">PropertyName</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-UniqueFormalParameters">UniqueFormalParameters</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt id="_ref_90"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncFunctionBody" id="prod-AsyncFunctionBody">
    <emu-nt><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a="8ff4dc7c"><emu-nt params="~Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-FunctionBody">FunctionBody</a><emu-mods><emu-params>[~Yield, +Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="AwaitExpression" params="Yield" id="prod-AwaitExpression">
    <emu-nt params="Yield"><a href="#prod-AwaitExpression">AwaitExpression</a><emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="c19c56e7"><emu-t>await</emu-t><emu-nt params="?Yield, +Await"><a href="https://tc39.github.io/ecma262/#prod-UnaryExpression">UnaryExpression</a><emu-mods><emu-params>[?Yield, +Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></emu-grammar>

    <emu-note><span class="note">Note</span><div class="note-contents">
      <p><code>await</code> is parsed as an <emu-nt id="_ref_91"><a href="#prod-AwaitExpression">AwaitExpression</a></emu-nt> when the  <sub>[Await]</sub> parameter is present. The  <sub>[Await]</sub> parameter is present in the following contexts:</p>
      <ul>
        <li>In an <emu-nt id="_ref_92"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt>.</li>
        <li>In the <emu-nt><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a></emu-nt> of an <emu-nt id="_ref_93"><a href="#prod-AsyncFunctionDeclaration">AsyncFunctionDeclaration</a></emu-nt>, <emu-nt id="_ref_94"><a href="#prod-AsyncFunctionExpression">AsyncFunctionExpression</a></emu-nt>, <emu-nt>AsyncGeneratorDeclaration</emu-nt>, or <emu-nt>AsyncGeneratorExpression</emu-nt>. <emu-nt id="_ref_95"><a href="#prod-AwaitExpression">AwaitExpression</a></emu-nt> in this position is a Syntax error via static semantics.</li>
        <li><ins>When <emu-nt id="_ref_96"><a href="#prod-Module">Module</a></emu-nt> is the syntactic <emu-xref href="#sec-context-free-grammars"><a href="https://tc39.github.io/ecma262/#sec-context-free-grammars">goal symbol</a></emu-xref></ins></li>
      </ul>
      <p><del>When <emu-nt id="_ref_97"><a href="#prod-Module">Module</a></emu-nt> is the syntactic <emu-xref href="#sec-context-free-grammars"><a href="https://tc39.github.io/ecma262/#sec-context-free-grammars">goal symbol</a></emu-xref> and the  <sub>[Await]</sub> parameter is absent, <code>await</code> is parsed as a keyword and will be a Syntax error.</del> When <emu-nt><a href="https://tc39.github.io/ecma262/#prod-Script">Script</a></emu-nt> is the syntactic <emu-xref href="#sec-context-free-grammars"><a href="https://tc39.github.io/ecma262/#sec-context-free-grammars">goal symbol</a></emu-xref>, <code>await</code> may be parsed as an identifier when the  <sub>[Await]</sub> parameter is absent. This includes the following contexts:</p>
      <ul>
        <li>Anywhere outside of an <emu-nt id="_ref_98"><a href="#prod-AsyncFunctionBody">AsyncFunctionBody</a></emu-nt> or <emu-nt><a href="https://tc39.github.io/ecma262/#prod-FormalParameters">FormalParameters</a></emu-nt> of an <emu-nt id="_ref_99"><a href="#prod-AsyncFunctionDeclaration">AsyncFunctionDeclaration</a></emu-nt>, <emu-nt id="_ref_100"><a href="#prod-AsyncFunctionExpression">AsyncFunctionExpression</a></emu-nt>, <emu-nt>AsyncGeneratorDeclaration</emu-nt>, or <emu-nt>AsyncGeneratorExpression</emu-nt>.</li>
        <li>In the <emu-nt><a href="https://tc39.github.io/ecma262/#prod-BindingIdentifier">BindingIdentifier</a></emu-nt> of a <emu-nt><a href="https://tc39.github.io/ecma262/#prod-FunctionExpression">FunctionExpression</a></emu-nt>, <emu-nt><a href="https://tc39.github.io/ecma262/#prod-GeneratorExpression">GeneratorExpression</a></emu-nt>, or <emu-nt>AsyncGeneratorExpression</emu-nt>.</li>
      </ul>
    </div></emu-note>
</emu-clause>
</emu-clause></div></body>